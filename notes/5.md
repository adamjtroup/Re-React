# 5

With the previous solution, we ingorned the way React is actually supposed to render the DOM: process all work concurrently then update the DOM in a single batch. Right now, it updates the DOM as it processes work.

So, we can not longer appendChild() directly in performUnitOfWork(). Instead, we have to 1. recognize when we have processed every node and 2. commit the changes to the DOM in a single batch. We know that if we arrive back at the root node, all nodes are processed, so let's recognize that:

```js
function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }

​  // ! This is where we check if we are back at the root
  // If we are here, it's time to commit everything
  if (!nextUnitOfWork && wipRoot) { 
    commitRoot()
  }
​
  requestIdleCallback(workLoop)
}
```

And we can actually commit work to the DOM with these simple functions:

```js
function commitRoot() {
  commitWork(wipRoot.child)
  wipRoot = null
}
​
function commitWork(fiber) {
  if (!fiber) {
    return
  }
  const domParent = fiber.parent.dom
  domParent.appendChild(fiber.dom)
  commitWork(fiber.child) // Commit everything recursively depth-first
  commitWork(fiber.sibling) // After the child is committed, move onto the sibling
}
```

You can still see how it follows the pattern of: 1. go to child 2. go to sibling 3. go to unc.

Now, we simply process the entire fiber tree, recognize when it's done, and commit all changes in one batch.