# 1

Step 1 serves to introduce you to the idea of React and how it works with native JavaScript. It also describes a critical part of making React applications: creating elements dynamically.

React code snippet:

```js
const element = <h1 title="foo">Hello</h1> // Define a new element
const container = document.getElementById("root") // Get an element to embed it in
ReactDOM.render(element, container) // Execute render
```

`JSX` works similarly to an interpreter, translating ergonomic React code into valid raw JS.

React can create elements via function call using `createElement`. This is what it looks like:

```js
// Example element in HTML:
<h1 title="foo">Hello</h1>

// Constructing that element via a function call from its parts:
const element = React.createElement(
  type: "h1", // The element's type (h1, p, div, ...).
  props: { // Element tags/parameters and inner content
    title: "foo",
    children: "Hello" // Usually the 'children' isn't a simple string. Usually a / many subcomponent(s) with possibly infinite nested objects
  },
)
```

The above example represents line 1 of the initial example code. The `createElement` call is that element represented in valid JS as an object. So, now we know how to represent HTML (non-valid JS) as a valid JS object, just like any other JS object you'd create.

ReactDOM.render() is not a valid native JS call. But, we know what it does. It manipulates the DOM. So, let's convert that to valid JS:

```js
// 'element' var from above still exists
// This will introduce each part of the element to the renderer, one-by-one
const node = document.createElement(element.type) // Create and clarify the element's type
node["title"] = element.props.title // Give the element the title parameter

// Establish the element's children (raw text in this case)
const text = document.createTextNode("")
text["nodeValue"] = element.props.children

// Append the text to the created node as a child
node.appendChild(text)

// Append the node, which now contains all the information / parameters we needed
// In this case, the node is a child of the root of the html body (core element)
container.appendChild()
```

Now we can create our own `createElement()` function given this information to translate JSX to valid JS. Something important to remember when creating a new language / framework is that you want to have the end in mind. Define what your end code will look like, then figure out how to translate to that given your toolkit (native JS in this case). 

```js
// Example createElement()

function createElement(type, props, ...children) {
  return {
    type, // Explicitly set the element type first
    props: {
      // Receive every prop for the element using the spread op
      // The '...' operator ensures the whole passed 'props' obj (could have multiple key-value pairs)
      // is exactly mirrored to the returned 'props' object.
      ...props, 
      children, // Everything else (now in array form) is returned as inner content (children)
    }
  }
}

// Example usages:

// 1
createElement("div")
// -> Returns object:
{
  "type": "div",
  "props": { children: [] }
}
// -> This will represent this element:
<div></div>


// 2
createElement("div", null, a, b, c) // a, b, and c are all existing nodes/elements here
// -> Returns object:
{
  "type": "div",
  "props": { children: [a, b, c] }
}
```

The children passed here could also be primitive data, not JS objects to nest in the element. Since HTML really just renders everything primitive as text, we can just wrap primitive data in a text-based element. This requires a revision to the `createElement()` function:

```js
function createElement(type, props, ...children) {
  return {
    type: type,
    props: {
      ...props,
      children: children.map(child => // Map through all children and convert any non-object values (primitive data) to text elements
        typeof child === "object"
          ? child
          : createTextElement(child) // Helper function to create text-based elements
      )
    }
  }
}
```

You don't have to create a helper function to create text elements, but all that differs between them is the inner text. This means every creation of text elements is extremely similar, warranting the use of a helper function for convenience. DRY.

```js
function createTextElement(text) {
  return {
    type: "TEXT_ELEMENT", // Always hardcoded to be a text element
    props: { // Props values will never change between any text elements
      nodeValue: text,
      children: []
    }
  }
}
```

It's about time we established the JS library that this will be contained in: ReReact. So far, the only functionality ReReact has is to create elements:

```js
const Rereact = { // Core lib object
  createElement, // The createElement() function above is already defined
}
```

Here's an realistic example of what its usage would look like at this point:

```js
const element = Rereact.createElement(
  "div",
  { className: "container" },
  Rereact.createElement("a", { href: "www.site.com" }, "Link"),
  Rereact.createElement("b", null, "Access page above")
)

// That element represented as JSX:

const element = (
  <div className="container">
    <a href="www.site.com">Link</a>
    <b>Access page above</b>
  </div>
)
```

By the way, if you've ever wondered why we use `className` instead of `class` in JSX, it's simply because `class` is a reserved keyword in JS.