# 3

The previous 2 parts produced code that will technically **work*. However, in realistic applications it would be very slow. This is due to a lack of concurrency. It's important to note that with that solution, once you start rendering, it doesn't stop until it is fully rendered. This blocks the main thread for a while if you have to render a large, heavily nested component. That will completely block the main thread until rendering is done. On web pages, which users expect to be lightning fast, use smooth animations, etc. a choppy render is extremly undesirable.

So, let's make this jawn concurrent:

```js
let nextUnitOfWork = null
​
function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
  requestIdleCallback(workLoop)
}
​
requestIdleCallback(workLoop)
​
function performUnitOfWork(nextUnitOfWork) {
  // TODO
}
```