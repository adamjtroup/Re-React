# 6

So far, the code only *adds* nodes to the DOM. It's time to add updating and deleting.

In order to update or delete something, you need to have a reference to that thing's previous state. So, saving a reference of the active DOM tree will be necessary:

```js
let nextUnitOfWork = null
let currentRoot = null // Reference
let wipRoot = null // New
```

In addition to this, we add an `alternate` field to every fiber to store a reference to the old fiber that was previously committed. This is used to 'reconcile' old fibers with new elements. Concretely, this is what that looks like:

- Iterate over the elements list and previous fiber tree in parallel. We do this by creating instances of `oldFiber`, a reference to the previous fiber, and `element`, the new thing we want to render to the DOM.
- Compare these 2 elements to see if any changes need to be applied to the DOM. You do this by comparing their type. Here is the decision making tree for that:
  - If the old fiber's type === new element's type, then keep the DOM node and update it with new props
  - If the type is different and there is a new element, create a new DOM node
  - If the types are different and there is no new element, delete that DOM node

In practice, that looks like this:

```js
// Check whether the types are identical
const sameType =
      oldFiber &&
      element &&
      element.type == oldFiber.type
```